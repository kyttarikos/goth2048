<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2048 — for Denise</title>
  <style>
    /* Fonts */
    @font-face {
      font-display: swap;
      font-family: 'UnifrakturMaguntia';
      font-style: normal;
      font-weight: 400;
      src: url('../fonts/unifrakturmaguntia-v21-latin-regular.woff2') format('woff2');
    }

    :root{
      --bg:#0b0606; /* deep black */
      --panel:#1a0d0d; /* dark red-black */
      --accent:#c41b2f; /* blood red */
      --muted: rgba(255,255,255,0.08);
      --tile-text: #fff;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: "Times New Roman", Times, serif;
      background: radial-gradient(circle at 10% 10%, rgba(196,27,47,0.06) 0%, transparent 20%), var(--bg);
      color:var(--tile-text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* moving translucent background text */
    .bg-text-wrap{
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:0;
    }
    .bg-text{
      position:absolute;
      white-space:pre-wrap;
      font-size:20px;
      line-height:1.25;
      color:var(--accent);
      opacity:0.12; /* readable but not opaque */
      mix-blend-mode:screen;
      filter: blur(0.2px);
    }
    /* center, top-down */
    .bg-text.center{
      left:50%;
      transform:translateX(-50%);
      width:100%;
      max-width:900px;
      text-align:center;
      animation: slideDownUp 30s linear infinite alternate;
    }
    .bg-text.center.alt{
      animation-duration:36s;
      animation-direction:alternate-reverse;
      opacity:0.08;
      transform:translateX(-50%) scale(1.05);
    }
    /* sides vertical, opposite movement */
    .bg-text.side{
      top:0;
      height:100%;
      writing-mode: vertical-rl;
      font-size:16px;
      opacity:0.08;
    }
    .bg-text.side.left{ left:0; animation: slideUp 40s linear infinite alternate; }
    .bg-text.side.right{ right:0; animation: slideDown 40s linear infinite alternate; }

    @keyframes slideDownUp{ from{transform:translateX(-50%) translateY(-10%)} to{transform:translateX(-50%) translateY(120%)} }
    @keyframes slideUp{ from{ transform: translateY(100%) rotate(180deg); } to{ transform: translateY(-100%) rotate(180deg); } }
    @keyframes slideDown{ from{ transform: translateY(-100%) rotate(180deg); } to{ transform: translateY(100%) rotate(180deg); } }

    /* game container */
    .container{ width:420px; max-width:92vw; z-index:2; position:relative; }

    header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:14px; }

    .title{ font-family: 'UnifrakturMaguntia', cursive; font-weight:400; letter-spacing:1px; font-size:26px; color:var(--accent); }
    .subtitle{font-size:12px; color:var(--muted);}    

    .scoreboard{ display:flex; gap:10px; align-items:center; }
    .score{ background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); padding:8px 12px; border-radius:8px; text-align:center; min-width:72px; }
    .score .num{font-weight:700; font-size:16px}

    .controls{display:flex; gap:8px; margin-top:8px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;color:var(--tile-text);cursor:pointer;font-size:13px}
    .btn:hover{border-color:var(--accent)}

    .board-wrap{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:18px; border-radius:12px; box-shadow: 0 8px 30px rgba(0,0,0,0.6); position:relative; }

    .grid{ width:384px; max-width:86vw; height:384px; background:var(--panel); border-radius:8px; padding:12px; display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr); gap:12px; position:relative; }

    .cell{ background:var(--glass); border-radius:6px; }

    /* tiles layer is now a child of .grid so positioning is relative to the grid interior */
    .tiles{ position:absolute; inset:12px; border-radius:8px; pointer-events:none; }

    .tile{ position:absolute; display:flex; align-items:center; justify-content:center; border-radius:6px; font-weight:800; font-size:22px; transition: transform 160ms ease, opacity 160ms ease; will-change:transform,opacity; box-shadow:0 6px 18px rgba(0,0,0,0.6); color:var(--tile-text); }
    .tile.large{ font-size:18px; padding:6px }

    .tile.v2{background:#2b0909}
    .tile.v4{background:#3b0c0c}
    .tile.v8{background:#c41b2f}
    .tile.v16{background:#9b1018}
    .tile.v32{background:#e03b4e}
    .tile.v64{background:#ff6b6b}
    .tile.v128{background:#f2a6aa; color:#111}
    .tile.v256{background:#f6c5c8; color:#111}
    .tile.v512{background:#ffebeef; color:#111}

    .tile.appear{ transform: scale(0.2); opacity:0; }
    .tile.showup{ transform: scale(1); opacity:1; }

    .tile.merged{ animation: pop 200ms ease; }
    @keyframes pop{ from{transform:scale(1.12)} to{transform:scale(1)} }

    .overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:4; pointer-events:none }
    .message{ background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); padding:18px 22px; border-radius:10px; text-align:center; color:#fff; pointer-events:auto }

    footer{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}

    @media (max-width:420px){ .grid{ width:calc(92vw); height:calc(92vw) } }
  </style>
</head>
<body>
  <div class="bg-text-wrap" aria-hidden="true">
    <div class="bg-text center">I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever, ever...
Ever get the feeling that you're never all alone?
And I remember now.
At the top of my lungs
in my arms, she dies...
she dies!
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna catch me.
If I fall...
If I fall down...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna...</div>

    <div class="bg-text center alt">I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...</div>

    <div class="bg-text side left">I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...</div>

    <div class="bg-text side right">I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...</div>
  </div>

  <main class="container" role="main">
    <header>
      <div>
        <div class="title">2048</div>
        <div class="subtitle">red & black — for denise</div>
      </div>
      <div class="scoreboard">
        <div class="score" id="scoreBox"><div style="font-size:11px;opacity:0.7">SCORE</div><div class="num" id="score">0</div></div>
        <div class="score" id="bestBox"><div style="font-size:11px;opacity:0.7">BEST</div><div class="num" id="best">0</div></div>
      </div>
    </header>

    <div class="board-wrap">
      <div class="grid" id="grid">
        <!-- base cells for layout (16) -->
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>

        <!-- tiles layer is a child of the grid so its coordinates align with the grid interior -->
        <div class="tiles" id="tiles"></div>
      </div>

      <div class="overlay" id="overlay" style="display:none">
        <div class="message" id="messageBox">
          <div id="messageText"></div>
          <div style="margin-top:8px">
            <button class="btn" id="tryAgain">Try again</button>
          </div>
        </div>
      </div>

    </div>

    <div class="controls">
      <button class="btn" id="newGame">New Game</button>
      <button class="btn" id="undoBtn">Undo</button>
      <div style="flex:1"></div>
      <div style="font-size:12px;color:var(--muted);align-self:center">for denise. ily &lt;3 - i.m.</div>
    </div>

    <footer>
      Controls: Arrow keys / WASD / Swipe. Goal: make 2048 tile.
    </footer>
  </main>

  <script>
  /* Full rewrite: animated sliding & merging tiles; tiles layer inside .grid; no template literals in HTML; lyrics inserted. */
  (function(){
    const SIZE = 4;
    const ANIM = 160; // ms animation duration (matches CSS)
    let gridEl = document.getElementById('grid');
    let tilesLayer = document.getElementById('tiles');
    let scoreEl = document.getElementById('score');
    let bestEl = document.getElementById('best');
    let overlay = document.getElementById('overlay');
    let messageText = document.getElementById('messageText');

    let score = 0;
    let best = Number(localStorage.getItem('denise_2048_best') || 0);
    bestEl.textContent = best;

    // game state
    let board = createEmpty(); // holds tile objects or null
    let tiles = [];            // list of tile objects {id,value,row,col,el}
    let previous = null;       // undo snapshot
    let animating = false;

    function createEmpty(){ return Array.from({length:SIZE},()=>Array(SIZE).fill(null)); }

    function getMetrics(){
      const cell = gridEl.querySelector('.cell');
      const cellRect = cell.getBoundingClientRect();
      const gapPx = parseInt(getComputedStyle(gridEl).getPropertyValue('gap')) || 12;
      return {cellSize: Math.round(cellRect.width), gap: gapPx};
    }

    function updateScore(){ scoreEl.textContent = score; if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('denise_2048_best', best); } }

    function createTile(row,col,value,opts={appear:true}){
      const id = 't'+(Date.now().toString(36))+'-'+Math.floor(Math.random()*10000);
      const el = document.createElement('div');
      el.className = 'tile v'+value + (value>=128? ' large':'');
      el.textContent = value;
      el.style.position = 'absolute';
      el.style.opacity = '1';
      const tile = {id,value,row,col,el,merged:false,merging:false};
      tiles.push(tile);
      board[row][col] = tile;
      tilesLayer.appendChild(el);
      // size & position
      placeTileElement(tile, opts && opts.scale ? opts.scale : 1, opts && opts.noTransition);
      if(opts && opts.appear){
        // small pop: start scaled down then expand
        requestAnimationFrame(()=>{
          el.classList.add('showup');
          // ensure transform includes scale(1)
          placeTileElement(tile, 1);
        });
      }
      return tile;
    }

    function placeTileElement(tile, scale=1, noTransition=false){
      const {cellSize, gap} = getMetrics();
      const left = tile.col * (cellSize + gap);
      const top = tile.row * (cellSize + gap);
      tile.el.style.width = cellSize + 'px';
      tile.el.style.height = cellSize + 'px';
      tile.el.style.lineHeight = cellSize + 'px';
      tile.el.style.transition = noTransition ? 'none' : `transform ${ANIM}ms ease, opacity ${ANIM}ms ease`;
      // place using translate + scale so CSS transition animates movement and pop
      tile.el.style.transform = `translate(${left}px, ${top}px) scale(${scale})`;
    }

    function rebuildFromState(state){
      // used for undo: destroy current DOM and rebuild from state.board
      // clear
      tilesLayer.innerHTML = '';
      tiles = [];
      board = createEmpty();
      state.board.forEach((row,rowIdx)=>{
        row.forEach((cell, colIdx)=>{
          if(cell){
            const t = createTile(cell.row, cell.col, cell.value, {appear:false, noTransition:true});
            // ensure proper id
            t.id = cell.id;
          }
        });
      });
      renderPositions(true);
      score = state.score || 0; updateScore();
    }

    function renderPositions(noTransition){
      tiles.forEach(t=>{
        placeTileElement(t, 1, noTransition);
        // update appearance classes
        updateTileClass(t);
      });
    }

    function updateTileClass(t){
      // normalize classes to v{value} and large
      const classes = ['tile','v'+t.value];
      if(t.value>=128) classes.push('large');
      if(t.merged) classes.push('merged');
      t.el.className = classes.join(' ');
      t.el.textContent = t.value;
    }

    function addRandom(){
      const empties = [];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!board[r][c]) empties.push([r,c]);
      if(!empties.length) return false;
      const [r,c] = empties[Math.floor(Math.random()*empties.length)];
      const value = Math.random()<0.9 ? 2 : 4;
      // create tile with tiny scale, then animate to normal
      createTile(r,c,value,{appear:true});
      // small visual: set initial scale 0.2, then animate to 1
      const t = board[r][c];
      t.el.style.transform = t.el.style.transform + ' scale(0.2)';
      requestAnimationFrame(()=>{ placeTileElement(t,1); });
      return true;
    }

    function checkEnd(){
      if(tiles.some(t=>t.value===2048)){ showMessage('You win!'); return; }
      if(!hasMoves()){ showMessage('Game over'); }
    }

    function hasMoves(){
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(!board[r][c]) return true;
        if(c < SIZE-1 && board[r][c].value === board[r][c+1]?.value) return true;
        if(r < SIZE-1 && board[r][c].value === board[r+1][c]?.value) return true;
      }
      return false;
    }

    function showMessage(msg){ messageText.textContent = msg; overlay.style.display = 'flex'; }

    function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

    function cloneStateForUndo(){
      return {
        board: board.map((row,r)=>row.map(cell=> cell ? { id: cell.id, value: cell.value, row: cell.row, col: cell.col } : null )),
        score
      };
    }

    async function move(direction){
      if(animating) return; // ignore input during animation
      const vector = { left: [0,-1], right: [0,1], up: [-1,0], down: [1,0] }[direction];
      if(!vector) return;

      previous = cloneStateForUndo();

      let moved = false;
      animating = true;

      // traversal order depends on direction
      const rows = [...Array(SIZE).keys()];
      const cols = [...Array(SIZE).keys()];
      if(vector[0] === 1) rows.reverse();
      if(vector[1] === 1) cols.reverse();

      // reset merged flags
      tiles.forEach(t=>{ t.merged = false; t.merging = false; t.toRemove = false; });

      const merges = [];

      for(const r of rows){
        for(const c of cols){
          const tile = board[r][c];
          if(!tile) continue;
          let curR = r, curC = c;
          // slide as far as possible
          while(true){
            const nr = curR + vector[0], nc = curC + vector[1];
            if(nr<0 || nr>=SIZE || nc<0 || nc>=SIZE) break;
            const occupant = board[nr][nc];
            if(!occupant){
              // empty -> move
              board[curR][curC] = null;
              board[nr][nc] = tile;
              tile.row = nr; tile.col = nc;
              curR = nr; curC = nc;
              moved = true;
              continue;
            }
            // occupant exists
            if(occupant.value === tile.value && !occupant.merged && !tile.merging){
              // merge into occupant
              board[curR][curC] = null;
              tile.row = nr; tile.col = nc; // move visually into the target
              tile.merging = true;
              merges.push({from: tile, to: occupant});
              moved = true;
            }
            break; // tile can't move further
          }
        }
      }

      if(!moved){ animating = false; return; }

      // animate movement: update element transforms
      renderPositions();
      await wait(ANIM + 20);

      // finalize merges
      for(const m of merges){
        const from = m.from, to = m.to;
        // remove "from" tile element after overlaying at same position
        from.toRemove = true;
        from.el.style.opacity = '0';
        // double the target value
        to.value = to.value * 2;
        to.merged = true;
        updateTileClass(to);
        // update board reference (from was already removed from its old spot)
        board[to.row][to.col] = to;
        score += to.value;
      }

      // wait a bit for merged pop
      await wait(120);
      // remove merged-from elements and filter tiles
      tiles.filter(t=>t.toRemove).forEach(t=>{ if(t.el && t.el.parentNode) t.el.parentNode.removeChild(t.el); });
      tiles = tiles.filter(t=>!t.toRemove);

      // cleanup merged visuals
      tiles.forEach(t=>{ t.merged = false; updateTileClass(t); });

      updateScore();

      // add a random tile
      addRandom();

      // final render to ensure everything in place
      renderPositions();
      await wait(ANIM + 20);

      checkEnd();
      animating = false;
    }

    // keyboard
    window.addEventListener('keydown',(e)=>{
      const key = e.key;
      if(['ArrowLeft','a','A'].includes(key)){ e.preventDefault(); move('left'); }
      if(['ArrowRight','d','D'].includes(key)){ e.preventDefault(); move('right'); }
      if(['ArrowUp','w','W'].includes(key)){ e.preventDefault(); move('up'); }
      if(['ArrowDown','s','S'].includes(key)){ e.preventDefault(); move('down'); }
    });

    // touch swipe
    let startX=null, startY=null;
    window.addEventListener('touchstart',e=>{ const t = e.touches[0]; startX = t.clientX; startY = t.clientY; },{passive:true});
    window.addEventListener('touchend',e=>{
      if(startX===null) return; const t = e.changedTouches[0]; const dx = t.clientX - startX; const dy = t.clientY - startY; const absX=Math.abs(dx), absY=Math.abs(dy);
      if(Math.max(absX,absY) > 30){ if(absX>absY) move(dx>0? 'right':'left'); else move(dy>0? 'down':'up'); }
      startX = startY = null;
    },{passive:true});

    document.getElementById('newGame').addEventListener('click', ()=>{ startNewGame(); });
    document.getElementById('tryAgain').addEventListener('click', ()=>{ startNewGame(); });
    document.getElementById('undoBtn').addEventListener('click', ()=>{
      if(previous){ rebuildFromState(previous); previous = null; overlay.style.display='none'; }
    });

    function clearAll(){ board = createEmpty(); tiles.forEach(t=>{ if(t.el && t.el.parentNode) t.el.parentNode.removeChild(t.el); }); tiles = []; }

    function startNewGame(){
      clearAll(); score = 0; updateScore(); overlay.style.display='none';
      addRandom(); addRandom();
      // ensure positions are correct after layout
      setTimeout(()=> renderPositions(true), 20);
    }

    // initial
    startNewGame();

    // resize handler
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      // re-flow tile sizes and positions (no transitions)
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{ renderPositions(true); }, 80);
    });

  })();
  </script>
</body>
</html>
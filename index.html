<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Goth 2048 — Denise</title>
  <link href="https://fonts.googleapis.com/css2?family=UnifrakturCook&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0b0b;
      --panel:#0f0f0f;
      --accent:#b30000;
      --tile-dark:#1b1b1b;
      --glass: rgba(255,255,255,0.03);
      --font-head: 'UnifrakturCook', serif;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background:linear-gradient(180deg,#000 0%,#0a0a0a 100%);
      color:#eee;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }

    /* moving translucent background text */
    .bg-lyrics{
      position:fixed; inset:0; z-index:0; pointer-events:none; overflow:hidden;
      display:flex; align-items:center; justify-content:center;
    }
    .bg-lyrics .layer{
      position:absolute; white-space:pre-wrap; text-align:center; font-family:var(--font-head);
      font-size:32px; line-height:1.1; opacity:0.06; color:var(--accent);
      transform:rotate(-8deg); will-change:transform;
      animation: drift 40s linear infinite;
      padding:0 10vw;
    }
    .bg-lyrics .layer.two{font-size:20px; opacity:0.03; animation-duration:60s; transform:rotate(6deg)}
    .bg-lyrics .layer.three{font-size:14px; opacity:0.02; animation-duration:90s;}
    @keyframes drift{
      0%{transform:translateY(-30vh) rotate(-8deg)}
      50%{transform:translateY(30vh) rotate(2deg)}
      100%{transform:translateY(-30vh) rotate(-8deg)}
    }

    /* game panel */
    .container{
      width: min(96vw,720px);
      max-width:720px;
      z-index:2;
      display:grid; gap:18px; grid-template-columns:1fr 240px; align-items:start;
      padding:28px;
    }

    .left{
      background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(15,0,0,0.2));
      border-radius:12px; padding:20px; box-shadow: 0 10px 40px rgba(0,0,0,0.7);
      backdrop-filter:blur(6px);
    }

    header{display:flex; justify-content:space-between; align-items:center; gap:12px}
    h1{font-family:var(--font-head); margin:0; font-size:34px; color:var(--accent); letter-spacing:1px}
    .sub{font-size:12px; opacity:0.7}

    .scorebox{background:var(--panel); border-radius:8px; padding:10px 12px; text-align:center}
    .scorebox .num{font-weight:700; font-size:20px}

    .board{
      width:100%; aspect-ratio:1/1; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,0,0,0.02));
      border-radius:10px; padding:16px; display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin-top:18px;
      box-shadow: inset 0 2px 0 rgba(255,0,0,0.03);
      position:relative; overflow:hidden;
    }

    .cell{
      background:var(--tile-dark); border-radius:8px; min-height:0; display:flex; align-items:center; justify-content:center; color:rgba(255,255,255,0.05);
      font-weight:700; font-size:22px; user-select:none;
    }

    /* tile visuals */
    .tile{
      position:absolute; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:800; transition: transform 160ms ease, opacity 120ms ease, background-color 120ms ease, box-shadow 120ms ease;
      will-change:transform, opacity;
      text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    }
    .tile .label{padding:12px 8px; font-size:22px}

    /* values */
    .t-2{background:rgba(255,255,255,0.04)}
    .t-4{background:rgba(255,255,255,0.06)}
    .t-8{background:rgba(179,0,0,0.12)}
    .t-16{background:rgba(179,0,0,0.18)}
    .t-32{background:rgba(179,0,0,0.26)}
    .t-64{background:rgba(179,0,0,0.36)}
    .t-128{background:rgba(179,0,0,0.45)}
    .t-256{background:rgba(179,0,0,0.55)}
    .t-512{background:rgba(179,0,0,0.66)}
    .t-1024{background:rgba(179,0,0,0.76)}
    .t-2048{background:linear-gradient(135deg,#ff5050,#b30000)}

    /* right panel */
    .right{background:var(--panel); border-radius:12px; padding:14px; height:100%; display:flex; flex-direction:column; gap:14px}
    .controls{font-size:13px; opacity:0.9}

    footer{grid-column:1 / -1; text-align:center; margin-top:8px; opacity:0.9}
    .signature{font-family:var(--font-head); font-size:16px; color:var(--accent)}

    /* responsive */
    @media (max-width:740px){
      .container{grid-template-columns:1fr;}
      .right{order:2}
    }

    /* transition for spawn */
    .pop{animation:pop 160ms ease forwards}
    @keyframes pop{from{transform:scale(0.2); opacity:0} to{transform:scale(1); opacity:1}}

    /* overlay messages */
    .overlay{position:absolute; inset:0; z-index:6; display:flex; align-items:center; justify-content:center; pointer-events:none}
    .message{background:rgba(0,0,0,0.7); padding:18px 24px; border-radius:10px; color:#fff; font-weight:700; font-size:20px; pointer-events:auto}

  </style>
</head>
<body>

  <div class="bg-lyrics" aria-hidden>
    <div class="layer">I never said I'd lie in wait forever... If I died, we'd be together, now. I can't always just forget her. But she could try... At the end of the world, or the last thing I see you are never coming home, never coming home--Could I? Should I? And all the things that you never ever told me, and all the smiles that are ever, ever... Ever get the feeling that you're never all alone? And I remember now. At the top of my lungs in my arms, she dies... she dies! At the end of the world, or the last thing I see you are never coming home, never coming home--Could I? Should I? And all the things that you never ever told me, and all the smiles that are ever gonna haunt me--Never coming home, never coming home--Could I? Should I? And all the wounds that are ever gonna scar me, for all the ghosts that are never gonna catch me. If I fall... If I fall down... At the end of the world, or the last thing I see you are never coming home, never coming home--Could I? Should I? And all the things that you never ever told me, and all the smiles that are ever gonna haunt me--Never coming home, never coming home--Could I? Should I? And all the wounds that are ever gonna scar me, for all the ghosts that are never gonna...</div>
    <div class="layer two">I never said I'd lie in wait forever... If I died, we'd be together, now... </div>
    <div class="layer three">never coming home, never coming home--Could I? Should I?</div>
  </div>

  <main class="container">
    <section class="left">
      <header>
        <div>
          <h1>Goth 2048</h1>
          <div class="sub">red & black • for Denise</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="scorebox">
            <div class="sub">SCORE</div>
            <div id="score" class="num">0</div>
          </div>
          <button id="newBtn" title="New game" style="background:var(--accent); color:#111; border:none; padding:8px 12px; border-radius:8px; font-weight:700; cursor:pointer">NEW</button>
        </div>
      </header>

      <div id="board" class="board" aria-label="2048 game board">
        <!-- grid cells rendered by JS -->
      </div>
      <footer>
        <div class="signature">ily &lt;3 - i.m.</div>
      </footer>
    </section>

    <aside class="right">
      <div style="font-weight:800; letter-spacing:0.6px">Controls</div>
      <div class="controls">
        <ul>
          <li>Arrow keys (← ↑ → ↓) or WASD to move tiles</li>
          <li>Swipe on mobile to move (fast & responsive)</li>
          <li>Click NEW to restart</li>
        </ul>
      </div>

      <div style="font-size:13px; opacity:0.9">Goal: combine tiles to reach 2048. Smooth animations and subtle goth theming included.</div>
    </aside>

  </main>

  <div id="overlay" class="overlay" style="display:none"><div class="message" id="messageText"></div></div>

<script>
// Simple 2048 implementation with smooth transforms and touch/swipe
const SIZE = 4;
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const overlay = document.getElementById('overlay');
const messageText = document.getElementById('messageText');
const newBtn = document.getElementById('newBtn');

let grid = [];
let tiles = {};
let score = 0;
let animating = false;

function createGrid(){
  grid = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
  boardEl.innerHTML = '';
  // create static cells
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell = document.createElement('div');
      cell.className='cell';
      boardEl.appendChild(cell);
    }
  }
}

function randEmpty(){
  const empties = [];
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++)if(!grid[r][c])empties.push([r,c]);
  return empties[Math.floor(Math.random()*empties.length)];
}

function spawn(){
  const pos = randEmpty();
  if(!pos) return false;
  const [r,c] = pos;
  const val = Math.random()<0.9?2:4;
  const id = 't'+Date.now()+Math.random().toString(36).slice(2,7);
  grid[r][c] = {val,id};
  drawTile(r,c,grid[r][c],true);
  return true;
}

function drawTile(row,col,obj,spawnAnim){
  const size = boardEl.clientWidth - 32; // inner padding
  const cellSize = (size - (SIZE-1)*12)/SIZE;
  const tile = document.createElement('div');
  tile.className='tile pop '+('t-'+obj.val);
  tile.style.width = cellSize + 'px';
  tile.style.height = cellSize + 'px';
  tile.dataset.id = obj.id;
  const label = document.createElement('div'); label.className='label'; label.textContent = obj.val;
  tile.appendChild(label);
  boardEl.appendChild(tile);
  tiles[obj.id] = tile;
  // position
  positionTile(obj.id,row,col);
  if(spawnAnim) tile.classList.add('pop');
}

function positionTile(id,row,col){
  const el = tiles[id];
  if(!el) return;
  const rect = boardEl.getBoundingClientRect();
  const size = rect.width - 32;
  const cellSize = (size - (SIZE-1)*12)/SIZE;
  const x = col*(cellSize+12) + 16;
  const y = row*(cellSize+12) + 16;
  el.style.transform = `translate(${x}px, ${y}px)`;
}

function rebuildAll(){
  // reposition and update tiles
  for(let id in tiles){
    // find tile location in grid
    let found=false;
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      const cell = grid[r][c];
      if(cell && cell.id===id){ positionTile(id,r,c); found=true; }
    }
    if(!found){ // tile was removed
      const el = tiles[id]; if(el){ el.remove(); delete tiles[id]; }
    }
  }
}

function move(direction){
  if(animating) return;
  animating = true;
  let moved=false;
  let mergedThisTurn = new Set();

  const dirVectors = {
    'left':[0,-1], 'right':[0,1], 'up':[-1,0], 'down':[1,0]
  };
  const [dr,dc] = dirVectors[direction];

  const rangeR = [...Array(SIZE).keys()];
  const rangeC = [...Array(SIZE).keys()];
  if(direction==='right') rangeC.reverse();
  if(direction==='down') rangeR.reverse();

  const moves = [];

  for(let r of rangeR){
    for(let c of rangeC){
      const cell = grid[r][c];
      if(!cell) continue;
      let rr=r, cc=c;
      while(true){
        const nr = rr+dr, nc = cc+dc;
        if(nr<0||nr>=SIZE||nc<0||nc>=SIZE) break;
        const next = grid[nr][nc];
        if(!next){ rr=nr; cc=nc; continue; }
        if(next.val===cell.val && !mergedThisTurn.has(next.id) && !mergedThisTurn.has(cell.id)){
          // merge into next
          moves.push({from:[r,c],to:[nr,nc],merge:true, id:cell.id});
          mergedThisTurn.add(next.id);
          break;
        }
        break;
      }
      if(rr!==r||cc!==c){ moves.push({from:[r,c],to:[rr,cc],merge:false, id:cell.id}); }
    }
  }

  if(moves.length===0){ animating=false; return; }

  // apply moves visually first
  for(const m of moves){
    const [fr,fc]=m.from; const [tr,tc]=m.to;
    const cell = grid[fr][fc];
    grid[fr][fc]=null;
    if(m.merge){
      // find target tile (already at tr,tc)
      const target = grid[tr][tc];
      const newVal = target.val + cell.val;
      // remove moving tile DOM after animation and update target value
      positionTile(cell.id,tr,tc);
      // delay update
      setTimeout(()=>{
        // update grid target
        grid[tr][tc] = {val:newVal,id:target.id};
        // remove moving tile element
        const el = tiles[cell.id]; if(el){ el.remove(); delete tiles[cell.id]; }
        // update target tile label and classes
        const tEl = tiles[target.id]; if(tEl){ tEl.querySelector('.label').textContent=newVal; tEl.className='tile '+('t-'+newVal); tEl.classList.add('pop'); }
        score += newVal; scoreEl.textContent = score;
      },160);
    } else {
      grid[tr][tc] = cell; // just move reference
      positionTile(cell.id,tr,tc);
    }
  }

  // after animation, spawn new tile and cleanup
  setTimeout(()=>{
    // collapse duplicates (some merges will have overwritten temporary references)
    // ensure DOM positioning matches grid
    rebuildAll();
    spawn();
    animating=false;
    checkGameState();
  },200);
}

function checkGameState(){
  // win check
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
    if(grid[r][c] && grid[r][c].val>=2048){ showMessage('You win!'); return; }
  }
  // any moves left?
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++)if(!grid[r][c])return;
  // check adjacent equal
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
    const v = grid[r][c].val;
    if(r<SIZE-1 && grid[r+1][c].val===v) return;
    if(c<SIZE-1 && grid[r][c+1].val===v) return;
  }
  showMessage('Game over');
}

function showMessage(text){
  messageText.textContent = text;
  overlay.style.display='flex';
  setTimeout(()=>{ overlay.style.display='none'; },1400);
}

function newGame(){
  createGrid();
  tiles = {}; score = 0; scoreEl.textContent=0; overlay.style.display='none';
  for(let i=0;i<2;i++) spawn();
}

window.addEventListener('resize', ()=>{ rebuildAll(); });

// keyboard
window.addEventListener('keydown', e=>{
  const key = e.key.toLowerCase();
  if(['arrowleft','arrowup','arrowright','arrowdown'].includes(e.key.toLowerCase())) e.preventDefault();
  if(key==='arrowleft' || key==='a') move('left');
  if(key==='arrowright' || key==='d') move('right');
  if(key==='arrowup' || key==='w') move('up');
  if(key==='arrowdown' || key==='s') move('down');
});

// touch swipe
let touchStart = null;
window.addEventListener('touchstart', e=>{ if(e.touches.length===1) touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY, t:Date.now()}; });
window.addEventListener('touchend', e=>{
  if(!touchStart) return; const dx = (e.changedTouches[0].clientX - touchStart.x); const dy = (e.changedTouches[0].clientY - touchStart.y);
  const absX = Math.abs(dx), absY = Math.abs(dy);
  if(Math.max(absX,absY) > 30){
    if(absX>absY){ if(dx>0) move('right'); else move('left'); }
    else{ if(dy>0) move('down'); else move('up'); }
  }
  touchStart=null;
});

newBtn.addEventListener('click', newGame);

// init
createGrid(); newGame();

</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2048 — for denise</title>

<style>
/* === Fonts === */
@font-face {
  font-display: swap;
  font-family: 'UnifrakturMaguntia';
  font-style: normal;
  font-weight: 400;
  src: url('../fonts/unifrakturmaguntia-v21-latin-regular.woff2') format('woff2');
}
:root{
  --bg:#0b0606;
  --panel:#120808;
  --tile-text:#fff;
  --accent:#b90a0a; /* red */
  --muted: rgba(255,255,255,0.08);
  --tile-0: rgba(255,255,255,0.03);
  --tile-2: #2a0b0b;
  --tile-4: #3a0d0d;
  --tile-8: #4b0f0f;
  --tile-16:#5d1212;
  --tile-32:#6f1616;
  --tile-64:#8a1b1b;
  --tile-128:#a02020;
  --tile-256:#bf2929;
  --tile-512:#d73b3b;
  --tile-1024:#e85a5a;
  --tile-2048:#ff7b7b;
}

/* === Page === */
html,body{
  height:100%;
  margin:0;
  background:var(--bg);
  color:var(--tile-text);
  font-family: "Times New Roman", Times, serif;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
  box-sizing:border-box;
}

/* === Background lyrics === */
.bg-lyrics{
  position:fixed;
  inset:0;
  z-index:0;
  pointer-events:none;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
}
.lyric-stripe{
  position:absolute;
  width:120%;
  left:-10%;
  font-family: 'UnifrakturMaguntia', "Times New Roman", serif;
  font-size:20px;
  line-height:1.4;
  white-space:pre-wrap;
  text-align:center;
  opacity:0.12;
  color:#ff0000;
  transform:translateY(0);
  will-change:transform;
  user-select:none;
}

/* two stripes alternate direction and timing */
.lyric-stripe.a{
  animation: slideDown 40s linear infinite;
}
.lyric-stripe.b{
  animation: slideUp 40s linear infinite;
  animation-delay: 20s;
}

/* Keyframes for alternating slide directions */
@keyframes slideDown{
  0%{ transform:translateY(-110%); }
  50%{ transform:translateY(10%); }
  100%{ transform:translateY(110%); }
}
@keyframes slideUp{
  0%{ transform:translateY(110%); }
  50%{ transform:translateY(-10%); }
  100%{ transform:translateY(-110%); }
}

/* === Game container === */
.container{
  width:520px;
  max-width:96vw;
  position:relative;
  z-index:2;
}

/* header */
.header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:12px;
  gap:12px;
}
.title{
  font-family: 'UnifrakturMaguntia', "Times New Roman", serif;
  font-size:28px;
  color:var(--accent);
  letter-spacing:1px;
}
.controls{
  display:flex;
  gap:8px;
  align-items:center;
}
.button{
  background:transparent;
  border:1px solid rgba(255,255,255,0.08);
  color:var(--tile-text);
  padding:8px 10px;
  border-radius:6px;
  cursor:pointer;
  font-size:14px;
}
.score{
  background:var(--panel);
  padding:8px 12px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.06);
  text-align:center;
}

/* panel */
.panel{
  background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.65));
  padding:18px;
  border-radius:12px;
  box-shadow: 0 6px 30px rgba(0,0,0,0.6);
  position:relative;
}

/* grid */
.grid{
  width:100%;
  aspect-ratio:1/1;
  background:rgba(0,0,0,0.2);
  border-radius:8px;
  padding:12px;
  box-sizing:border-box;
  position:relative;
}
.row{
  display:flex;
  gap:12px;
  height:calc((100% - 36px)/4);
  margin-bottom:12px;
}
.row:last-child{ margin-bottom:0; }
.cell{
  flex:1;
  background:var(--tile-0);
  border-radius:6px;
  position:relative;
}

/* tiles container sits on top of cell grid */
.tiles{
  position:absolute;
  inset:12px;
  pointer-events:none;
}

/* tile */
.tile{
  position:absolute;
  border-radius:6px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  color:var(--tile-text);
  box-sizing:border-box;
  transition: transform 150ms ease, left 150ms ease, top 150ms ease;
  transform-origin:center center;
  will-change: transform, left, top;
  padding:6px;
  text-align:center;
  font-size:24px;
  user-select:none;
  border: 1px solid rgba(0,0,0,0.2);
}

/* spawn animation using scale */
.tile.new {
  animation: pop 160ms ease;
}
@keyframes pop{
  0%{ transform: scale(0.2); }
  60%{ transform: scale(1.08); }
  100%{ transform: scale(1); }
}

/* merged pulse */
.tile.merged {
  animation: merged 200ms ease;
}
@keyframes merged{
  0%{ transform: scale(1); }
  50%{ transform: scale(1.14); }
  100%{ transform: scale(1); }
}

/* tile colors by value */
.tile.v2{ background:var(--tile-2); }
.tile.v4{ background:var(--tile-4); }
.tile.v8{ background:var(--tile-8); }
.tile.v16{ background:var(--tile-16); font-size:20px; }
.tile.v32{ background:var(--tile-32); font-size:20px; }
.tile.v64{ background:var(--tile-64); font-size:20px; }
.tile.v128{ background:var(--tile-128); font-size:18px; }
.tile.v256{ background:var(--tile-256); font-size:18px; }
.tile.v512{ background:var(--tile-512); font-size:16px; }
.tile.v1024{ background:var(--tile-1024); font-size:15px; }
.tile.v2048{ background:var(--tile-2048); font-size:14px; }

/* footer note */
.note{
  text-align:center;
  margin-top:12px;
  opacity:0.9;
  font-size:13px;
  color:rgba(255,255,255,0.8);
}
.credit{
  margin-top:6px;
  font-family: 'UnifrakturMaguntia', "Times New Roman", serif;
  color:var(--accent);
  font-size:14px;
}

/* small helper for message overlays */
.overlay{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0.75));
  z-index:10;
  border-radius:12px;
  color:white;
  font-size:28px;
  text-align:center;
  padding:24px;
}
.hidden{ display:none; }
.small{ font-size:14px; opacity:0.9; margin-top:8px; }

@media (max-width:520px){
  .title{ font-size:20px; }
  .note{ font-size:12px; }
  .lyric-stripe{ font-size:14px; }
}
</style>
</head>
<body>

<!-- translucent moving background lyrics -->
<div class="bg-lyrics" aria-hidden="true">
  <div class="lyric-stripe a" id="lyricA">
I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever, ever...
Ever get the feeling that you're never all alone?
And I remember now.
At the top of my lungs
in my arms, she dies...
she dies!
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna catch me.
If I fall...
If I fall down...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna...
  </div>

  <div class="lyric-stripe b" id="lyricB">
I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever, ever...
Ever get the feeling that you're never all alone?
And I remember now.
At the top of my lungs
in my arms, she dies...
she dies!
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna catch me.
If I fall...
If I fall down...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna...
  </div>
</div>

<!-- game container -->
<div class="container">
  <div class="header">
    <div>
      <div class="title">2048</div>
      <div style="font-size:12px;opacity:0.85">red • black edition</div>
    </div>

    <div class="controls">
      <div class="score" id="scoreBox">Score<br><strong id="score">0</strong></div>
      <button class="button" id="newGameBtn">New Game</button>
    </div>
  </div>

  <div class="panel">
    <div class="grid" id="grid">
      <!-- grid cells (visual) -->
      <div class="cells" id="cells" style="position:absolute;inset:12px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:12px;z-index:0;">
        <!-- created by JS -->
      </div>

      <!-- tiles live here -->
      <div class="tiles" id="tiles"></div>

      <!-- overlays -->
      <div class="overlay hidden" id="gameOverOverlay">
        Game Over<br><div class="small">Press New Game to try again</div>
      </div>
      <div class="overlay hidden" id="winOverlay">
        You Win!<br><div class="small">Keep going or start new game</div>
      </div>
    </div>

    <div class="note">
      Controls: arrow keys / WASD / swipe. <div class="credit">for denise. ily &lt;3 - i.m.</div>
    </div>
  </div>
</div>

<script>
/* 2048-like implementation (compact but functional)
   grid is 4x4, values stored as numbers (0 empty).
   tiles are DOM elements absolutely positioned inside .tiles.
*/

/* ========== Config ========== */
const SIZE = 4;
const TILE_MARGIN = 12; // must match CSS gap/padding
const gridEl = document.getElementById('grid');
const tilesContainer = document.getElementById('tiles');
const cellsContainer = document.getElementById('cells');
const scoreBox = document.getElementById('score');
const newBtn = document.getElementById('newGameBtn');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const winOverlay = document.getElementById('winOverlay');

let board = [];
let score = 0;
let tileSizePx = 0;
let tileGapPx = 12;
let tilePositions = {}; // track DOM tiles by id
let freshTiles = new Set();

/* ===== Setup visual grid cells ===== */
function buildCells(){
  cellsContainer.innerHTML = '';
  for(let i=0;i<SIZE*SIZE;i++){
    const c = document.createElement('div');
    c.className='cell';
    cellsContainer.appendChild(c);
  }
}
buildCells();

/* ===== Helpers ===== */
function emptyBoard(){
  board = [];
  for(let r=0;r<SIZE;r++){
    board.push(new Array(SIZE).fill(0));
  }
}
function rndInt(n){ return Math.floor(Math.random()*n); }

function coordsToTopLeft(r,c){
  // compute pixel position using cell sizes
  const rect = cellsContainer.getBoundingClientRect();
  const cellW = rect.width / SIZE;
  const cellH = rect.height / SIZE;
  const left = c * cellW;
  const top = r * cellH;
  return {left, top, w: cellW, h: cellH};
}

/* create tile DOM */
let nextTileId = 1;
function createTile(value, r, c, isNew=false){
  const d = document.createElement('div');
  const id = 't' + (nextTileId++);
  d.className = `tile v${value} ${isNew? 'new':''}`;
  d.dataset.id = id;
  d.dataset.value = value;
  d.style.width = '0px';
  d.style.height = '0px';
  d.style.left = '0px';
  d.style.top = '0px';
  d.textContent = value;
  tilesContainer.appendChild(d);
  tilePositions[id] = {el: d, r, c, v:value};
  // ensure animation classes removed later
  if(isNew){
    setTimeout(()=>d.classList.remove('new'), 220);
  }
  return id;
}

/* update tile visuals (position & size & color) */
function layoutTiles(){
  const rect = cellsContainer.getBoundingClientRect();
  const cellW = rect.width / SIZE;
  const cellH = rect.height / SIZE;
  for(const id in tilePositions){
    const t = tilePositions[id];
    const el = t.el;
    const pos = coordsToTopLeft(t.r, t.c);
    el.style.width = (cellW) + 'px';
    el.style.height = (cellH) + 'px';
    el.style.left = pos.left + 'px';
    el.style.top = pos.top + 'px';
    el.style.lineHeight = (cellH - 12) + 'px';
    // update classes by value
    el.className = 'tile v' + t.v + (t.merged? ' merged':'') + (t.new? ' new':'');
    el.dataset.value = t.v;
    el.textContent = t.v;
    if(t.merged){
      setTimeout(()=>{ if(t.el) t.el.classList.remove('merged'); t.merged=false; }, 220);
    }
  }
}

/* remove all tile DOMs */
function clearTiles(){
  tilesContainer.innerHTML = '';
  for(const k in tilePositions) delete tilePositions[k];
}

/* spawn random tile (2 or 4) */
function addRandomTile(isNew=true){
  const empties = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(board[r][c]===0) empties.push({r,c});
    }
  }
  if(empties.length===0) return false;
  const pick = empties[rndInt(empties.length)];
  const value = Math.random() < 0.9 ? 2 : 4;
  board[pick.r][pick.c] = value;
  // create DOM tile
  const id = createTile(value, pick.r, pick.c, isNew);
  tilePositions[id].new = isNew;
  layoutTiles();
  return true;
}

/* rotation helpers to fold logic into left-move */
function rotateLeft(b){
  const n = SIZE;
  const nb = [];
  for(let r=0;r<n;r++){
    nb.push(new Array(n).fill(0));
  }
  for(let r=0;r<n;r++){
    for(let c=0;c<n;c++){
      nb[n-1-c][r] = b[r][c];
    }
  }
  return nb;
}
function rotateRight(b){
  const n = SIZE;
  const nb = [];
  for(let r=0;r<n;r++) nb.push(new Array(n).fill(0));
  for(let r=0;r<n;r++){
    for(let c=0;c<n;c++){
      nb[c][n-1-r] = b[r][c];
    }
  }
  return nb;
}
function rotate180(b){
  const n=SIZE; const nb=[];
  for(let r=0;r<n;r++){
    nb.push(new Array(n).fill(0));
  }
  for(let r=0;r<n;r++){
    for(let c=0;c<n;c++){
      nb[n-1-r][n-1-c] = b[r][c];
    }
  }
  return nb;
}

/* compress row to left, merging as 2048 rules */
function moveLeftOnce(b){
  let moved=false;
  let gained = 0;
  const newBoard = b.map(row => row.slice());
  for(let r=0;r<SIZE;r++){
    // compress non-zero
    const arr = newBoard[r].filter(x=>x!==0);
    for(let i=0;i<arr.length-1;i++){
      if(arr[i] === arr[i+1]){
        arr[i] = arr[i] * 2;
        gained += arr[i];
        arr.splice(i+1,1);
      }
    }
    while(arr.length < SIZE) arr.push(0);
    for(let c=0;c<SIZE;c++){
      if(newBoard[r][c] !== arr[c]) moved = true;
      newBoard[r][c] = arr[c];
    }
  }
  return {moved, board:newBoard, gained};
}

/* check if any moves possible */
function canMove(b){
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(b[r][c]===0) return true;
      if(c+1<SIZE && b[r][c]===b[r][c+1]) return true;
      if(r+1<SIZE && b[r][c]===b[r+1][c]) return true;
    }
  }
  return false;
}

/* do move in one of four directions: 'left','right','up','down' */
async function doMove(dir){
  if(isAnimating) return;
  let original = board.map(row=>row.slice());
  let rotated;
  if(dir==='left'){
    rotated = original;
  } else if(dir==='right'){
    rotated = rotate180(original);
  } else if(dir==='up'){
    rotated = rotateLeft(original);
  } else if(dir==='down'){
    rotated = rotateRight(original);
  } else return;

  const res = moveLeftOnce(rotated);
  if(!res.moved) return false; // no move

  // update board to rotated result before spawn
  let newRot = res.board;
  // rotate back
  let final;
  if(dir==='left') final = newRot;
  else if(dir==='right') final = rotate180(newRot);
  else if(dir==='up') final = rotateRight(newRot);
  else if(dir==='down') final = rotateLeft(newRot);

  // animate tiles from original positions to new positions
  await animateBoardTransition(original, final);

  board = final;
  score += res.gained;
  scoreBox.textContent = score;

  // spawn new tile after move (with small delay to allow slide)
  addRandomTile(true);

  // check win (>=2048)
  if(board.some(r=>r.some(v=>v>=2048))){
    winOverlay.classList.remove('hidden');
    setTimeout(()=>winOverlay.classList.add('hidden'), 1600);
  }

  if(!canMove(board)){
    gameOverOverlay.classList.remove('hidden');
  }
  return true;
}

/* === Animation: animate tile DOMs from original to new positions ===
   Strategy: create mapping of tile elements from original non-zero cells,
   then for each target cell with a value, find if it originates from a single
   tile (move), or two tiles (merge). Simpler approach: remove all tile DOMs,
   create new DOMs at original positions, then update their r/c to final positions,
   letting CSS transitions move them; when merging, mark merged to play pulse.
*/
let isAnimating = false;
async function animateBoardTransition(orig, fin){
  isAnimating = true;
  // clear existing DOM and re-create tiles representing orig state
  clearTiles();
  // For reproducible mapping: create tiles for each non-zero orig cell with unique ids
  const mapIds = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const v = orig[r][c];
      if(v!==0){
        const id = createTile(v, r, c, false);
        tilePositions[id].v = v;
        mapIds.push({id, r, c, v});
      }
    }
  }
  layoutTiles();

  // compute destination counts to detect merges
  const destCounts = {};
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const v = fin[r][c];
      if(v!==0){
        const key = r+','+c;
        destCounts[key] = (destCounts[key]||0) + 1;
      }
    }
  }

  // Simple mapping heuristic:
  // For each destination cell (r,c) with value v:
  //  - if it existed exactly once in orig (no merge), move nearest tile with same value.
  //  - if it results from merge (two same smaller), then find two tiles and animate them to same dest, then convert to merged tile.
  // For implementation brevity we'll move tiles greedily by scanning orig tiles left-to-right to final left-to-right.

  // Build list of dest positions in reading order
  const destList = [];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(fin[r][c]!==0) destList.push({r,c,v:fin[r][c]});
  // Build list of source tiles in reading order
  const srcList = mapIds.slice();

  // Map sources to dests: greedily assign one source per dest, but if dest value equals double of source and there are two sources with same value,
  // the greedy approach will still assign them in sequence; later we mark merges by checking if multiple sources assigned to a dest.
  const assignments = {}; // destKey -> [sourceIds...]
  let sIdx = 0;
  for(let d of destList){
    const key = d.r+','+d.c;
    assignments[key] = assignments[key] || [];
    // determine how many source tiles should go to this dest.
    // If dest value appears in original as same value, likely one source; if it's a merge, two smaller values will map to it.
    // Simplify: if there are at least 2 sources remaining and srcList[sIdx].v * 2 === d.v, then assign two sources if they match.
    if(sIdx < srcList.length){
      // try to see if merge is likely
      if(sIdx+1 < srcList.length && srcList[sIdx].v + srcList[sIdx+1].v === d.v){
        assignments[key].push(srcList[sIdx].id, srcList[sIdx+1].id);
        sIdx += 2;
      } else {
        assignments[key].push(srcList[sIdx].id);
        sIdx += 1;
      }
    }
  }

  // animate: for each dest, move its assigned sources to dest's r/c; if multiple assigned -> mark merged
  for(const k in assignments){
    const [r,c] = k.split(',').map(x=>parseInt(x));
    const ids = assignments[k];
    for(const id of ids){
      if(!tilePositions[id]) continue;
      tilePositions[id].r = r;
      tilePositions[id].c = c;
    }
  }

  // trigger layout (causes CSS transitions)
  layoutTiles();

  // wait for slide transition to finish (~160ms)
  await new Promise(res => setTimeout(res, 170));

  // Now replace any groups that merged: if a dest had more than 1 source, remove the extra tiles and create one merged tile with merged animation
  // We'll find dests where assignments[key].length > 1
  for(const k in assignments){
    const ids = assignments[k];
    if(ids.length > 1){
      // compute value in final board at that dest
      const [r,c] = k.split(',').map(x=>parseInt(x));
      const v = fin[r][c];
      // remove source elements
      for(const id of ids){
        if(tilePositions[id] && tilePositions[id].el){
          tilePositions[id].el.remove();
          delete tilePositions[id];
        }
      }
      // create merged tile
      const newId = createTile(v, r, c, false);
      tilePositions[newId].merged = true;
      // remove merged class soon
      setTimeout(()=>{ if(tilePositions[newId]) tilePositions[newId].el.classList.remove('merged'); tilePositions[newId].merged=false; }, 260);
    }
  }

  // For non-merged single assignments, ensure we update their value if they changed (e.g., moved and became merged later)
  // Update surviving tile values to match final board values where unique
  const remainingIds = Object.keys(tilePositions);
  for(const id of remainingIds){
    const t = tilePositions[id];
    if(t){
      const finalVal = fin[t.r][t.c];
      if(finalVal && t.v !== finalVal){
        t.v = finalVal;
        t.el.className = 'tile v' + t.v;
        // brief merged pulse
        t.el.classList.add('merged');
        setTimeout(()=>t.el && t.el.classList.remove('merged'), 220);
      } else {
        t.el.className = 'tile v' + t.v;
      }
    }
  }

  // final layout
  layoutTiles();

  // wait just a touch to let merged pop run
  await new Promise(res => setTimeout(res, 120));
  isAnimating = false;
}

/* ==== Init & new game ==== */
function startNewGame(){
  emptyBoard();
  clearTiles();
  score = 0;
  scoreBox.textContent = score;
  gameOverOverlay.classList.add('hidden');
  winOverlay.classList.add('hidden');
  nextTileId = 1;
  // place two tiles
  addRandomTile(true);
  addRandomTile(true);
}
newBtn.addEventListener('click', startNewGame);

/* ===== Input handling ===== */
const keyMap = {
  'ArrowLeft':'left', 'ArrowRight':'right', 'ArrowUp':'up','ArrowDown':'down',
  'a':'left','A':'left','d':'right','D':'right','w':'up','W':'up','s':'down','S':'down'
};
document.addEventListener('keydown', (e)=>{
  const k = e.key;
  if(keyMap[k]){
    e.preventDefault();
    doMove(keyMap[k]);
  }
});

/* touch swipe */
let touchStartX=0, touchStartY=0, touchEndX=0, touchEndY=0;
gridEl.addEventListener('touchstart', (e)=>{
  if(e.touches.length>1) return;
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});
gridEl.addEventListener('touchend', (e)=>{
  if(!touchStartX && !touchStartY) return;
  touchEndX = e.changedTouches[0].clientX;
  touchEndY = e.changedTouches[0].clientY;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const absX = Math.abs(dx), absY = Math.abs(dy);
  const threshold = 24; // min px to count
  if(Math.max(absX,absY) < threshold) return;
  if(absX > absY){
    doMove(dx>0? 'right':'left');
  } else {
    doMove(dy>0? 'down':'up');
  }
  touchStartX = touchStartY = 0;
});

/* handle resize to re-layout tiles */
window.addEventListener('resize', ()=> layoutTiles());

/* start game */
startNewGame();

/* initial layout */
setTimeout(()=>layoutTiles(), 60);

</script>
</body>
</html>
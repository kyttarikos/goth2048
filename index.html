<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2048 — for Denise</title>

  <style>
    /* Fonts: user-specified WOFF2 then Times New Roman fallback */
    /* unifrakturmaguntia-regular - latin */
    @font-face {
      font-display: swap;
      font-family: 'UnifrakturMaguntia';
      font-style: normal;
      font-weight: 400;
      src: url('../fonts/unifrakturmaguntia-v21-latin-regular.woff2') format('woff2');
    }
    :root{
      --bg:#0b0606;
      --panel:#1a0d0d;
      --accent:#c41b2f;
      --muted: rgba(255,255,255,0.08);
      --tile-text: #fff;
      --glass: rgba(255,255,255,0.03);
      --gap: 12; /* px; used in JS to compute positions */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: "UnifrakturMaguntia", "Times New Roman", serif;
      background: radial-gradient(circle at 10% 10%, rgba(196,27,47,0.06) 0%, transparent 20%), var(--bg);
      color:var(--tile-text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* MOVING LYRICS - center + left + right (opposite directions) */
    .bg-text-wrap{
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:0;
    }
    .bg-text {
      position:absolute;
      white-space:pre-wrap;
      width:760px;
      max-width:80vw;
      left:50%;
      transform:translateX(-50%);
      text-align:center;
      color:var(--accent);
      opacity:0.10;
      mix-blend-mode:screen;
      filter: blur(0.2px);
      font-size:18px;
      line-height:1.25;
    }
    .bg-text.center {
      top:-20%;
      animation: slideCenter 40s linear infinite alternate;
    }
    @keyframes slideCenter{
      from{ transform:translateX(-50%) translateY(-10%) }
      to  { transform:translateX(-50%) translateY(120%) }
    }

    /* left and right vertical strips */
    .bg-text.side {
      width: 220px;
      max-width: 20vw;
      font-size:14px;
      line-height:1.1;
      top:0;
      bottom:0;
      height:100%;
      display:block;
      text-align:left;
      opacity:0.06;
      transform-origin:center;
    }
    .bg-text.left {
      left:8px;
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      animation: slideSideUp 34s linear infinite;
    }
    .bg-text.right {
      right:8px;
      writing-mode: vertical-rl;
      animation: slideSideDown 34s linear infinite;
    }
    @keyframes slideSideUp{
      from{ transform: rotate(180deg) translateY(60%) }
      to{   transform: rotate(180deg) translateY(-60%) }
    }
    @keyframes slideSideDown{
      from{ transform: translateY(-60%) }
      to{   transform: translateY(60%) }
    }

    /* container */
    .container{
      width:420px;
      max-width:92vw;
      z-index:2;
      position:relative;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:14px;
    }

    .title{
      font-weight:700;
      letter-spacing:1px;
      font-size:20px;
      color:var(--accent);
    }
    .subtitle{font-size:12px;color:var(--muted);}

    .scoreboard{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .score{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      padding:8px 12px;
      border-radius:8px;
      text-align:center;
      min-width:72px;
    }
    .score .num{font-weight:700;font-size:16px}
    .controls{display:flex;gap:8px;margin-top:8px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;color:var(--tile-text);cursor:pointer;font-size:13px}
    .btn:hover{border-color:var(--accent)}

    .board-wrap{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;
      border-radius:12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      position:relative;
    }

    /* grid */
    .grid{
      width:384px;
      max-width:86vw;
      height:384px;
      background:var(--panel);
      border-radius:8px;
      padding:12px;
      display:grid;
      grid-template-columns:repeat(4,1fr);
      grid-template-rows:repeat(4,1fr);
      gap:12px;
      position:relative;
      overflow:hidden;
    }

    .cell{
      background:var(--glass);
      border-radius:6px;
      display:flex;align-items:center;justify-content:center;
      font-weight:700;color:rgba(255,255,255,0.6);
    }

    /* tiles container aligned to inner grid padding: matches grid's padding (12px) */
    .tiles{
      position:absolute;
      top:12px; left:12px; right:12px; bottom:12px;
      border-radius:8px;
      pointer-events:none;
      z-index:2;
    }

    .tile{
      position:absolute;
      display:flex;align-items:center;justify-content:center;
      border-radius:6px;
      font-weight:800;
      font-size:22px;
      transition: transform 150ms ease, opacity 150ms ease;
      will-change:transform, opacity;
      box-shadow:0 6px 18px rgba(0,0,0,0.6);
      color:var(--tile-text);
      user-select:none;
      touch-action:none;
    }

    .tile.new { transform: scale(0.2); opacity:0; }
    .tile.show { transform: scale(1); opacity:1; transition: transform 160ms ease, opacity 160ms ease; }

    .tile.merged { animation: pop 220ms ease; }
    @keyframes pop{ 0%{ transform: scale(1.15) } 100%{ transform: scale(1) } }

    /* tile colors */
    .tile.v2{ background:#2b0909 }
    .tile.v4{ background:#3b0c0c }
    .tile.v8{ background:#c41b2f }
    .tile.v16{ background:#9b1018 }
    .tile.v32{ background:#e03b4e }
    .tile.v64{ background:#ff6b6b }
    .tile.v128{ background:#f2a6aa; color:#111 }
    .tile.v256{ background:#f6c5c8; color:#111 }
    .tile.v512{ background:#ffebeef; color:#111 }
    .tile.large{ font-size:18px; padding:6px }

    .overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:4;pointer-events:none
    }
    .message{
      background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);padding:18px 22px;border-radius:10px;text-align:center;color:#fff;pointer-events:auto
    }

    footer{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}

    @media (max-width:420px){
      .grid{width:calc(92vw);height:calc(92vw)}
    }
  </style>
</head>
<body>
  <div class="bg-text-wrap" aria-hidden="true">
    <div class="bg-text center" id="lyricsCenter">
I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home— ...</div>

    <div class="bg-text side left" id="lyricsLeft">
I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
</div>

    <div class="bg-text side right" id="lyricsRight">
I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
</div>
  </div>

  <main class="container" role="main">
    <header>
      <div>
        <div class="title">2048</div>
        <div class="subtitle">red & black — for denise</div>
      </div>
      <div class="scoreboard">
        <div class="score" id="scoreBox"><div style="font-size:11px;opacity:0.7">SCORE</div><div class="num" id="score">0</div></div>
        <div class="score" id="bestBox"><div style="font-size:11px;opacity:0.7">BEST</div><div class="num" id="best">0</div></div>
      </div>
    </header>

    <div class="board-wrap">
      <div class="grid" id="grid">
        <!-- base cells for layout -->
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      </div>

      <div class="tiles" id="tiles"></div>

      <div class="overlay" id="overlay" style="display:none">
        <div class="message" id="messageBox">
          <div id="messageText"></div>
          <div style="margin-top:8px">
            <button class="btn" id="tryAgain">Try again</button>
          </div>
        </div>
      </div>

    </div>

    <div class="controls">
      <button class="btn" id="newGame">New Game</button>
      <button class="btn" id="undoBtn">Undo</button>
      <div style="flex:1"></div>
      <div style="font-size:12px;color:var(--muted);align-self:center">for denise. ily &lt;3 - i.m.</div>
    </div>

    <footer>
      Controls: Arrow keys / WASD / Swipe. Goal: make 2048 tile.
    </footer>
  </main>

  <script>
  /* Full rewrite: animated sliding + merging + spawn animations.
     Approach:
     - Maintain board (4x4 numbers) and tileEntities (id, value, r, c, el).
     - When moving, compute target indices per line and animate each tile element to new transform.
     - If two tiles merge, animate both into same cell, then after transition update primary tile value and remove secondary with a small pop.
  */

  (function(){
    const SIZE = 4;
    const GAP = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 12;
    const grid = document.getElementById('grid');
    const tilesLayer = document.getElementById('tiles');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const messageText = document.getElementById('messageText');
    const tryAgain = document.getElementById('tryAgain');

    let board = createEmpty();
    let score = 0;
    let best = Number(localStorage.getItem('denise_2048_best') || 0);
    let previousState = null; // for undo {board, score, tileEntities snapshot}
    bestEl.textContent = best;

    let uid = 1;
    const tileEntities = new Map(); // id -> {id,value,r,c,el}

    function createEmpty(){ return Array.from({length:SIZE},()=>Array(SIZE).fill(0)); }

    // Helpers to compute cell size and position
    function getCellSize(){
      const cell = grid.querySelector('.cell');
      return cell ? Math.round(cell.getBoundingClientRect().width) : 84;
    }

    function getTilePos(r,c){
      const cellSize = getCellSize();
      const left = c * (cellSize + GAP);
      const top = r * (cellSize + GAP);
      return {left, top, size: cellSize};
    }

    // Create DOM tile
    function createTileEntity(value, r, c){
      const id = 't' + (uid++);
      const el = document.createElement('div');
      el.className = `tile v${value} new`;
      el.textContent = value;
      el.dataset.id = id;
      tilesLayer.appendChild(el);

      // position (will be set after append)
      const pos = getTilePos(r,c);
      el.style.width = pos.size + 'px';
      el.style.height = pos.size + 'px';
      // set initial transform small then show -> scale animation
      el.style.transform = `translate(${pos.left}px, ${pos.top}px) scale(0.2)`;
      // force reflow then show
      requestAnimationFrame(()=>{ el.classList.add('show'); el.style.transform = `translate(${pos.left}px, ${pos.top}px) scale(1)`; });

      const entity = { id, value, r, c, el };
      tileEntities.set(id, entity);
      return entity;
    }

    // Remove tile element
    function removeTileEntity(id){
      const ent = tileEntities.get(id);
      if(!ent) return;
      // fade out and remove
      ent.el.style.transition = 'transform 120ms ease, opacity 120ms ease';
      ent.el.style.opacity = '0';
      setTimeout(()=> { try{ ent.el.remove(); }catch(e){} }, 140);
      tileEntities.delete(id);
    }

    // update tile DOM classes (color/size) and text
    function updateTileAppearance(ent){
      ent.el.className = `tile v${ent.value}` + (ent.value>=128? ' large' : '') ;
      ent.el.textContent = ent.value;
      // small pop handled separately when merging
    }

    // place tile to given r,c by setting transform
    function moveTileTo(ent, r, c){
      const pos = getTilePos(r,c);
      ent.el.style.transition = 'transform 150ms cubic-bezier(.2,.8,.2,1)';
      ent.el.style.transform = `translate(${pos.left}px, ${pos.top}px) scale(1)`;
      ent.el.style.width = pos.size + 'px';
      ent.el.style.height = pos.size + 'px';
      ent.r = r; ent.c = c;
    }

    // Save for undo
    function snapshotForUndo(){
      // shallow copy board and tileEntities positions/values
      const b = board.map(r=>r.slice());
      const tiles = Array.from(tileEntities.values()).map(t => ({id:t.id, value:t.value, r:t.r, c:t.c}));
      previousState = { board: b, score, tiles };
    }

    // Restore undo snapshot
    function restoreUndo(){
      if(!previousState) return;
      // clear current tiles
      for(const t of Array.from(tileEntities.keys())) removeTileEntity(t);
      tileEntities.clear();
      // restore board
      board = previousState.board.map(r=>r.slice());
      score = previousState.score;
      updateScoreDisplay();
      // recreate tile entities
      for(const t of previousState.tiles){
        const ent = createTileEntity(t.value, t.r, t.c);
        // ensure id consistent (we'll override generated id)
        ent.id = t.id;
        ent.value = t.value;
        ent.r = t.r; ent.c = t.c;
        ent.el.dataset.id = t.id;
        tileEntities.set(t.id, ent);
      }
      previousState = null;
    }

    // Add a random tile (2 or 4)
    function addRandom(){
      const empties = [];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c]===0) empties.push([r,c]);
      if(!empties.length) return false;
      const [r,c] = empties[Math.floor(Math.random()*empties.length)];
      const v = Math.random()<0.9 ? 2 : 4;
      board[r][c] = v;
      createTileEntity(v, r, c);
      return true;
    }

    function updateScoreDisplay(){ scoreEl.textContent = score; if(score>best){ best = score; localStorage.setItem('denise_2048_best', best); bestEl.textContent = best; } }

    function renderBoardFromState(){
      // clear DOM tiles then recreate from board
      for(const t of Array.from(tileEntities.keys())) removeTileEntity(t);
      tileEntities.clear();
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        const v = board[r][c];
        if(v!==0) createTileEntity(v, r, c);
      }
      updateScoreDisplay();
    }

    // Collapse algorithm that returns movement plan and merges
    // For each line (array of cells), we'll generate move actions for tile entities.
    // Input: lineIndices: array of positions (e.g. for left move row r -> [[r,0],[r,1],[r,2],[r,3]])
    function processLine(lineIndices){
      // gather tiles in reading order
      const sources = [];
      for(const [r,c] of lineIndices){
        const val = board[r][c];
        if(val!==0){
          // find corresponding entity (there might be multiple identical values -> we rely on tileEntities mapping by r,c)
          const ent = findTileEntityAt(r,c);
          if(!ent){
            // fallback: create a temporary tile to avoid breakage
            const tmp = createTileEntity(val, r, c);
            sources.push(tmp);
          } else {
            sources.push(ent);
          }
        }
      }

      const actions = []; // each action: {type:'move'|'merge', sources:[ent,...], targetIndex}
      let targetIdx = 0;
      for(let i=0;i<sources.length;i++){
        const a = sources[i];
        const b = sources[i+1];
        if(b && a.value === b.value){
          // merge a and b into targetIdx
          actions.push({ type:'merge', sources:[a,b], value:a.value*2, targetIndex: targetIdx });
          i++; // skip b
        } else {
          actions.push({ type:'move', sources:[a], value:a.value, targetIndex: targetIdx });
        }
        targetIdx++;
      }
      // fill rest with empty moves (no action needed)
      return actions;
    }

    function findTileEntityAt(r,c){
      for(const ent of tileEntities.values()){
        if(ent.r===r && ent.c===c) return ent;
      }
      return null;
    }

    // Apply a move in direction: 'left','right','up','down'
    function move(direction){
      snapshotForUndo();
      let moved = false;
      let gain = 0;

      // We'll build newBoard from scratch and animate tileEntities accordingly.
      const newBoard = createEmpty();

      // Helper to get line indices
      function indicesForRow(r){
        if(direction==='left') return [[r,0],[r,1],[r,2],[r,3]];
        if(direction==='right') return [[r,3],[r,2],[r,1],[r,0]];
      }
      function indicesForCol(c){
        if(direction==='up') return [[0,c],[1,c],[2,c],[3,c]];
        if(direction==='down') return [[3,c],[2,c],[1,c],[0,c]];
      }

      const movePromises = [];

      if(direction==='left' || direction==='right'){
        for(let r=0;r<SIZE;r++){
          const line = indicesForRow(r);
          const actions = processLine(line);
          // apply actions to newBoard, animate tiles
          for(const act of actions){
            const targetIdx = act.targetIndex;
            const [tr, tc] = line[targetIdx];
            if(act.type==='move'){
              const ent = act.sources[0];
              if(ent.r !== tr || ent.c !== tc) moved = true;
              newBoard[tr][tc] = act.value;
              moveTileTo(ent, tr, tc);
              // ensure ent reflects new position/value
              ent.value = act.value; ent.r = tr; ent.c = tc;
              // update appearance (value unchanged)
            } else if(act.type==='merge'){
              const a = act.sources[0], b = act.sources[1];
              // pick 'a' as primary (will become merged tile), move both to target
              if(a.r !== tr || a.c !== tc) moved = true;
              if(b.r !== tr || b.c !== tc) moved = true;
              // move both visually
              moveTileTo(a, tr, tc);
              moveTileTo(b, tr, tc);
              newBoard[tr][tc] = act.value;
              gain += act.value;
              // after move finishes, update 'a' value and remove 'b'
              const p = new Promise(resolve=>{
                // wait for transition to end; use timeout slightly longer than CSS transition
                setTimeout(()=>{
                  // update primary
                  a.value = act.value;
                  updateTileAppearance(a);
                  // small pop
                  a.el.classList.add('merged');
                  // remove secondary
                  removeTileEntity(b.id);
                  resolve();
                }, 180);
              });
              movePromises.push(p);
            }
          }
        }
      } else { // up / down
        for(let c=0;c<SIZE;c++){
          const line = indicesForCol(c);
          const actions = processLine(line);
          for(const act of actions){
            const targetIdx = act.targetIndex;
            const [tr, tc] = line[targetIdx];
            if(act.type==='move'){
              const ent = act.sources[0];
              if(ent.r !== tr || ent.c !== tc) moved = true;
              newBoard[tr][tc] = act.value;
              moveTileTo(ent, tr, tc);
              ent.value = act.value; ent.r = tr; ent.c = tc;
            } else if(act.type==='merge'){
              const a = act.sources[0], b = act.sources[1];
              if(a.r !== tr || a.c !== tc) moved = true;
              if(b.r !== tr || b.c !== tc) moved = true;
              moveTileTo(a, tr, tc);
              moveTileTo(b, tr, tc);
              newBoard[tr][tc] = act.value;
              gain += act.value;
              const p = new Promise(resolve=>{
                setTimeout(()=>{
                  a.value = act.value;
                  updateTileAppearance(a);
                  a.el.classList.add('merged');
                  removeTileEntity(b.id);
                  resolve();
                }, 180);
              });
              movePromises.push(p);
            }
          }
        }
      }

      if(!moved){
        // Nothing moved: revert snapshot (undo) because we took snapshot before move
        previousState = null;
        return false;
      }

      // apply newBoard to model and update score
      board = newBoard;
      score += gain;
      updateScoreDisplay();

      // after pending merge cleanup, ensure tiles mapping matches board (some secondary removals already done).
      Promise.all(movePromises).then(()=>{
        // remove any tiles that no longer correspond to board (safety)
        for(const ent of Array.from(tileEntities.values())){
          if(board[ent.r][ent.c] !== ent.value) {
            // If tile value different, update appearance
            updateTileAppearance(ent);
          }
          // ensure element style matches size (in case viewport changed)
          const pos = getTilePos(ent.r, ent.c);
          ent.el.style.width = pos.size + 'px';
          ent.el.style.height = pos.size + 'px';
        }
      });

      // spawn random tile after a small delay so move animation is visible
      setTimeout(()=>{ addRandom(); renderConsistency(); checkEnd(); }, 100);
      return true;
    }

    function renderConsistency(){
      // Ensure DOM matches board for any missed cases (create missing tiles)
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        const v = board[r][c];
        if(v===0) continue;
        const ent = findTileEntityAt(r,c);
        if(!ent){
          // create a new tile instantly (this can happen when loading from storage)
          createTileEntity(v,r,c);
        } else {
          // ensure appearance matches value
          if(ent.value !== v){
            ent.value = v;
            updateTileAppearance(ent);
          }
          // ensure positioned correctly
          moveTileTo(ent,r,c);
        }
      }
      updateScoreDisplay();
    }

    function hasMoves(){
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(board[r][c]===0) return true;
        if(c<SIZE-1 && board[r][c]===board[r][c+1]) return true;
        if(r<SIZE-1 && board[r][c]===board[r+1][c]) return true;
      }
      return false;
    }

    function checkEnd(){
      // win
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(board[r][c]===2048){ showMessage('You win!'); return; }
      }
      if(!hasMoves()){ showMessage('Game over'); }
    }

    function showMessage(msg){
      messageText.textContent = msg;
      overlay.style.display = 'flex';
    }

    // Controls
    window.addEventListener('keydown', (e)=>{
      const key = e.key;
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','a','s','d','w','A','S','D','W'].includes(key)){
        e.preventDefault();
        if(key==='ArrowLeft' || key==='a' || key==='A') move('left');
        if(key==='ArrowRight' || key==='d' || key==='D') move('right');
        if(key==='ArrowUp' || key==='w' || key==='W') move('up');
        if(key==='ArrowDown' || key==='s' || key==='S') move('down');
      }
    });

    // touch swipe
    let touchStartX=null, touchStartY=null;
    window.addEventListener('touchstart',e=>{
      const t = e.touches[0]; touchStartX=t.clientX; touchStartY=t.clientY;
    },{passive:true});
    window.addEventListener('touchend',e=>{
      if(touchStartX===null) return; const t = e.changedTouches[0]; const dx=t.clientX - touchStartX; const dy=t.clientY - touchStartY;
      const absX=Math.abs(dx), absY=Math.abs(dy);
      if(Math.max(absX,absY)>30){
        if(absX>absY){ if(dx>0) move('right'); else move('left'); } else { if(dy>0) move('down'); else move('up'); }
      }
      touchStartX=null; touchStartY=null;
    },{passive:true});

    // Buttons
    document.getElementById('newGame').addEventListener('click', resetGame);
    tryAgain.addEventListener('click', resetGame);
    document.getElementById('undoBtn').addEventListener('click', ()=>{ restoreUndo(); overlay.style.display='none'; });

    // Reset game
    function resetGame(){
      previousState = null;
      // clear DOM tiles
      for(const id of Array.from(tileEntities.keys())) removeTileEntity(id);
      tileEntities.clear();
      board = createEmpty();
      score = 0; updateScoreDisplay();
      overlay.style.display='none';
      addRandom(); addRandom();
      renderConsistency();
    }

    // persist best when unload
    window.addEventListener('beforeunload', ()=>{ localStorage.setItem('denise_2048_best', best); });

    // initial
    resetGame();

    // handle resize to fix tile sizing/positions
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{ // throttle
        for(const ent of tileEntities.values()){
          const pos = getTilePos(ent.r, ent.c);
          ent.el.style.width = pos.size + 'px';
          ent.el.style.height = pos.size + 'px';
          ent.el.style.transition = 'none';
          ent.el.style.transform = `translate(${pos.left}px, ${pos.top}px) scale(1)`;
          // allow next frame to re-enable transitions
          requestAnimationFrame(()=>{ ent.el.style.transition = 'transform 150ms cubic-bezier(.2,.8,.2,1)'; });
        }
      }, 80);
    });

  })();
  </script>
</body>
</html>
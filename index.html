<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2048 — for Denise</title>
  <style>
    :root{
      --bg:#0b0606; /* deep black */
      --panel:#1a0d0d; /* dark red-black */
      --accent:#c41b2f; /* blood red */
      --muted: rgba(255,255,255,0.08);
      --tile-text: #fff;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(circle at 10% 10%, rgba(196,27,47,0.06) 0%, transparent 20%), var(--bg);
      color:var(--tile-text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* moving translucent background text */
    .bg-text-wrap{
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:0;
    }
    .bg-text{
      position:absolute;
      white-space:pre-wrap;
      font-size:20px;
      line-height:1.25;
      width:100%;
      max-width:900px;
      left:50%;
      transform:translateX(-50%);
      text-align:center;
      color:var(--accent);
      opacity:0.12; /* readable but not opaque */
      mix-blend-mode:screen;
      filter: blur(0.2px);
    }
    /* animation: slide down then up (alternate) */
    .bg-text.updown{
      top:-20%;
      animation: slideDownUp 30s linear infinite alternate;
    }
    .bg-text.updown.alt{
      top:60%;
      animation-duration:36s;
      animation-direction:alternate-reverse;
      opacity:0.08;
      transform:translateX(-50%) scale(1.05);
    }
    @keyframes slideDownUp{
      from{transform:translateX(-50%) translateY(-10%)}
      to{transform:translateX(-50%) translateY(120%)}
    }

    /* game container */
    .container{
      width:420px;
      max-width:92vw;
      z-index:2;
      position:relative;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:14px;
    }

    .title{
      font-weight:700;
      letter-spacing:1px;
      font-size:20px;
      color:var(--accent);
    }
    .subtitle{font-size:12px; color:var(--muted);}

    .scoreboard{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .score{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      padding:8px 12px;
      border-radius:8px;
      text-align:center;
      min-width:72px;
    }
    .score .num{font-weight:700; font-size:16px}
    .controls{display:flex; gap:8px; margin-top:8px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;color:var(--tile-text);cursor:pointer;font-size:13px}
    .btn:hover{border-color:var(--accent)}

    .board-wrap{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;
      border-radius:12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      position:relative;
    }

    .grid{
      width:384px;
      max-width:86vw;
      height:384px;
      background:var(--panel);
      border-radius:8px;
      padding:12px;
      display:grid;
      grid-template-columns:repeat(4,1fr);
      grid-template-rows:repeat(4,1fr);
      gap:12px;
      position:relative;
      overflow:hidden;
    }

    .cell{
      background:var(--glass);
      border-radius:6px;
      display:flex;align-items:center;justify-content:center;
      font-weight:700;color:rgba(255,255,255,0.6);
    }

    /* tiles layer */
    .tiles{
      position:absolute;inset:12px;border-radius:8px;pointer-events:none;
    }
    .tile{
      position:absolute;
      width:calc((384px - 12px*3)/4);
      height:calc((384px - 12px*3)/4);
      display:flex;align-items:center;justify-content:center;
      border-radius:6px;
      font-weight:800;
      font-size:22px;
      transition:transform 160ms ease, opacity 160ms ease;
      will-change:transform, opacity;
      box-shadow:0 6px 18px rgba(0,0,0,0.6);
      color:var(--tile-text);
    }

    /* tile colors */
    .tile.v2{background:#2b0909}
    .tile.v4{background:#3b0c0c}
    .tile.v8{background:#c41b2f}
    .tile.v16{background:#9b1018}
    .tile.v32{background:#e03b4e}
    .tile.v64{background:#ff6b6b}
    .tile.v128{background:#f2a6aa; color:#111}
    .tile.v256{background:#f6c5c8; color:#111}
    .tile.v512{background:#ffebeef; color:#111}
    .tile.large{font-size:18px;padding:6px}

    /* simple appear animation */
    .tile.new{transform:scale(0.2);opacity:0}
    .tile.show{transform:scale(1);opacity:1}

    /* merged pulse */
    .tile.merged{animation: pop 200ms ease}
    @keyframes pop{from{transform:scale(1.1)}to{transform:scale(1)}}

    /* overlay messages */
    .overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:4;pointer-events:none
    }
    .message{
      background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);padding:18px 22px;border-radius:10px;text-align:center;color:#fff;pointer-events:auto
    }

    footer{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}

    /* responsive tweaks */
    @media (max-width:420px){
      .grid{width:calc(92vw);height:calc(92vw)}
      .tile{width:calc((92vw - 12px*3)/4);height:calc((92vw - 12px*3)/4)}
    }
  </style>
</head>
<body>
  <div class="bg-text-wrap" aria-hidden="true">
    <div class="bg-text updown">I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever, ever...
Ever get the feeling that you're never all alone?
And I remember now.
At the top of my lungs
in my arms, she dies...
she dies!
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna catch me.
If I fall...
If I fall down...
At the end of the world,
or the last thing I see
you are never coming home,
never coming home—
Could I?
Should I?
And all the things that you never ever told me,
and all the smiles that are ever gonna haunt me—
Never coming home,
never coming home—
Could I?
Should I?
And all the wounds that are ever gonna scar me,
for all the ghosts that are never gonna...</div>
    <div class="bg-text updown alt">I never said I'd lie in wait forever...
If I died, we'd be together, now.
I can't always just forget her.
But she could try...</div>
  </div>

  <main class="container" role="main">
    <header>
      <div>
        <div class="title">2048</div>
        <div class="subtitle">red & black — for denise</div>
      </div>
      <div class="scoreboard">
        <div class="score" id="scoreBox"><div style="font-size:11px;opacity:0.7">SCORE</div><div class="num" id="score">0</div></div>
        <div class="score" id="bestBox"><div style="font-size:11px;opacity:0.7">BEST</div><div class="num" id="best">0</div></div>
      </div>
    </header>

    <div class="board-wrap">
      <div class="grid" id="grid">
        <!-- base cells for layout -->
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      </div>

      <div class="tiles" id="tiles"></div>

      <div class="overlay" id="overlay" style="display:none">
        <div class="message" id="messageBox">
          <div id="messageText"></div>
          <div style="margin-top:8px">
            <button class="btn" id="tryAgain">Try again</button>
          </div>
        </div>
      </div>

    </div>

    <div class="controls">
      <button class="btn" id="newGame">New Game</button>
      <button class="btn" id="undoBtn">Undo</button>
      <div style="flex:1"></div>
      <div style="font-size:12px;color:var(--muted);align-self:center">for denise. ily &lt;3 - i.m.</div>
    </div>

    <footer>
      Controls: Arrow keys / WASD / Swipe. Goal: make 2048 tile.
    </footer>
  </main>

  <script>
  /* 2048 core implementation (compact, reliable)
     Grid coordinates: row 0..3, col 0..3
  */
  (function(){
    const size = 4;
    let board = createEmpty();
    let score = 0;
    let best = Number(localStorage.getItem('denise_2048_best')||0);
    let previous = null; // for simple undo

    const tilesLayer = document.getElementById('tiles');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const messageText = document.getElementById('messageText');
    const tryAgain = document.getElementById('tryAgain');

    bestEl.textContent = best;

    function createEmpty(){
      return Array.from({length:size},()=>Array(size).fill(0));
    }

    function cloneBoard(b){return b.map(r=>r.slice())}

    function resetGame(){
      previous = null;
      board = createEmpty();
      score = 0; updateScore();
      overlay.style.display='none';
      addRandom(); addRandom();
      render();
    }

    function addRandom(){
      const empties=[];
      for(let r=0;r<size;r++)for(let c=0;c<size;c++)if(board[r][c]===0)empties.push([r,c]);
      if(!empties.length) return false;
      const [r,c] = empties[Math.floor(Math.random()*empties.length)];
      board[r][c] = Math.random()<0.9?2:4;
      return true;
    }

    function updateScore(){ scoreEl.textContent = score; if(score>best){best=score; bestEl.textContent=best; localStorage.setItem('denise_2048_best', best);} }

    function render(){
      // clear tiles
      tilesLayer.innerHTML='';
      const cellSize = getCellSize();
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const val = board[r][c];
          if(val===0) continue;
          const tile = document.createElement('div');
          tile.className = 'tile v'+val + (val>=128?' large':'') + ' show';
          tile.textContent = val;
          // compute pos
          const left = c*(cellSize + 12);
          const top = r*(cellSize + 12);
          tile.style.transform = `translate(${left}px, ${top}px)`;
          tile.style.width = cellSize+'px';
          tile.style.height = cellSize+'px';
          tilesLayer.appendChild(tile);
        }
      }
    }

    function getCellSize(){
      const grid = document.getElementById('grid');
      const rect = grid.getBoundingClientRect();
      // grid has padding 12px around, and 3 gaps of 12px between columns
      // but easier: compute from first cell element
      const cell = grid.querySelector('.cell');
      return cell ? cell.getBoundingClientRect().width : 84;
    }

    function move(direction){
      // directions: 'left','right','up','down'
      previous = {board: cloneBoard(board), score};
      let moved=false;
      if(direction==='left' || direction==='right'){
        for(let r=0;r<size;r++){
          const line = board[r].slice();
          const {newLine, merged, gain} = collapse(line, direction==='right');
          if(!arraysEqual(newLine, board[r])){ moved=true; board[r]=newLine; score+=gain; }
        }
      } else {
        for(let c=0;c<size;c++){
          const col=[]; for(let r=0;r<size;r++)col.push(board[r][c]);
          const {newLine, merged, gain} = collapse(col, direction==='down');
          for(let r=0;r<size;r++){ if(board[r][c]!==newLine[r]) moved=true; board[r][c]=newLine[r]; }
          score+=gain;
        }
      }

      if(moved){ addRandom(); updateScore(); render(); checkEnd(); }
      return moved;
    }

    function collapse(line, reverse=false){
      // line: array of 4 numbers
      const arr = reverse?line.slice().reverse():line.slice();
      const filtered = arr.filter(x=>x!==0);
      const result = [];
      let gain=0;
      for(let i=0;i<filtered.length;i++){
        if(filtered[i]===filtered[i+1]){
          const v = filtered[i]*2;
          result.push(v);
          gain += v;
          i++; // skip next
        } else {
          result.push(filtered[i]);
        }
      }
      while(result.length<line.length) result.push(0);
      const newLine = reverse?result.slice().reverse():result.slice();
      return {newLine, gain};
    }

    function arraysEqual(a,b){
      for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true;
    }

    function hasMoves(){
      for(let r=0;r<size;r++)for(let c=0;c<size;c++){
        if(board[r][c]===0) return true;
        if(c<size-1 && board[r][c]===board[r][c+1]) return true;
        if(r<size-1 && board[r][c]===board[r+1][c]) return true;
      }
      return false;
    }

    function checkEnd(){
      // win check
      for(let r=0;r<size;r++)for(let c=0;c<size;c++) if(board[r][c]===2048){ showMessage('You win!'); return; }
      if(!hasMoves()){ showMessage('Game over'); }
    }

    function showMessage(msg){ messageText.textContent = msg; overlay.style.display='flex'; }

    // keyboard
    window.addEventListener('keydown', (e)=>{
      const key = e.key;
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','a','s','d','w','A','S','D','W'].includes(key)){
        e.preventDefault();
        if(key==='ArrowLeft' || key==='a' || key==='A') move('left');
        if(key==='ArrowRight' || key==='d' || key==='D') move('right');
        if(key==='ArrowUp' || key==='w' || key==='W') move('up');
        if(key==='ArrowDown' || key==='s' || key==='S') move('down');
      }
    });

    // touch swipe
    let touchStartX=null, touchStartY=null;
    window.addEventListener('touchstart',e=>{
      const t = e.touches[0]; touchStartX=t.clientX; touchStartY=t.clientY;
    },{passive:true});
    window.addEventListener('touchend',e=>{
      if(touchStartX===null) return; const t = e.changedTouches[0]; const dx=t.clientX - touchStartX; const dy=t.clientY - touchStartY;
      const absX=Math.abs(dx), absY=Math.abs(dy);
      if(Math.max(absX,absY)>30){
        if(absX>absY){ if(dx>0) move('right'); else move('left'); } else { if(dy>0) move('down'); else move('up'); }
      }
      touchStartX=null; touchStartY=null;
    },{passive:true});

    // buttons
    document.getElementById('newGame').addEventListener('click', resetGame);
    tryAgain.addEventListener('click', resetGame);
    document.getElementById('undoBtn').addEventListener('click', ()=>{
      if(previous){ board = cloneBoard(previous.board); score = previous.score; previous=null; updateScore(); render(); overlay.style.display='none'; }
    });

    // initial
    resetGame();

    // simple resize handler to re-render tile sizing
    window.addEventListener('resize', ()=>{ render(); });
  })();
  </script>
</body>
</html>
